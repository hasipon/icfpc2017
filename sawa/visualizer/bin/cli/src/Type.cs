// Generated by Haxe 3.4.2 (git build master @ 890f8c7)

#pragma warning disable 109, 114, 219, 429, 168, 162
public class ValueType : global::haxe.lang.ParamEnum {
	
	public ValueType(int index, object[] @params) : base(index, @params) {
	}
	
	
	public static readonly string[] __hx_constructs = new string[]{"TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"};
	
	public static readonly global::ValueType TNull = new global::ValueType(0, null);
	
	public static readonly global::ValueType TInt = new global::ValueType(1, null);
	
	public static readonly global::ValueType TFloat = new global::ValueType(2, null);
	
	public static readonly global::ValueType TBool = new global::ValueType(3, null);
	
	public static readonly global::ValueType TObject = new global::ValueType(4, null);
	
	public static readonly global::ValueType TFunction = new global::ValueType(5, null);
	
	public static global::ValueType TClass(global::System.Type c) {
		unchecked {
			return new global::ValueType(6, new object[]{c});
		}
	}
	
	
	public static global::ValueType TEnum(global::System.Type e) {
		unchecked {
			return new global::ValueType(7, new object[]{e});
		}
	}
	
	
	public static readonly global::ValueType TUnknown = new global::ValueType(8, null);
	
	public override string getTag() {
		return global::ValueType.__hx_constructs[this.index];
	}
	
	
}



#pragma warning disable 109, 114, 219, 429, 168, 162
public class Type : global::haxe.lang.HxObject {
	
	public Type(global::haxe.lang.EmptyObject empty) {
	}
	
	
	public Type() {
		global::Type.__hx_ctor__Type(this);
	}
	
	
	public static void __hx_ctor__Type(global::Type __hx_this) {
	}
	
	
	public static global::System.Type getClass<T>(T o) {
		if (( ( global::System.Object.ReferenceEquals(((object) (o) ), default(object)) || ( o is global::haxe.lang.DynamicObject ) ) || ( o is global::System.Type ) )) {
			return null;
		}
		
		return o.GetType();
	}
	
	
	public static global::Array<object> getClassFields(global::System.Type c) {
		if (global::System.Object.ReferenceEquals(((object) (c) ), ((object) (typeof(string)) ))) {
			return new global::Array<object>(new object[]{"fromCharCode"});
		}
		
		global::Array<object> ret = new global::Array<object>(new object[]{});
		global::System.Reflection.BindingFlags this1 = global::System.Reflection.BindingFlags.Public;
		global::System.Reflection.BindingFlags this2 = ((global::System.Reflection.BindingFlags) (( ((global::System.Reflection.BindingFlags) (this1) ) | ((global::System.Reflection.BindingFlags) (global::System.Reflection.BindingFlags.Static) ) )) );
		global::System.Reflection.MemberInfo[] infos = ((global::System.Type) (c) ).GetMembers(((global::System.Reflection.BindingFlags) (this2) ));
		{
			int _g1 = 0;
			int _g = ( infos as global::System.Array ).Length;
			while (( _g1 < _g )) {
				int i = _g1++;
				string name = infos[i].Name;
				if ( ! (name.StartsWith("__hx_")) ) {
					ret.push(name);
				}
				
			}
			
		}
		
		return ret;
	}
	
	
	public static global::ValueType @typeof(object v) {
		if (( v == null )) {
			return global::ValueType.TNull;
		}
		
		global::System.Type t = ((global::System.Type) (( v as global::System.Type )) );
		if ( ! (global::haxe.lang.Runtime.typeEq(t, null)) ) {
			return global::ValueType.TObject;
		}
		
		t = ((global::System.Type) (v.GetType()) );
		if (( t.IsEnum || ( v is global::haxe.lang.Enum ) )) {
			return global::ValueType.TEnum(((global::System.Type) (t) ));
		}
		
		if (t.IsValueType) {
			global::System.IConvertible vc = ((global::System.IConvertible) (v) );
			if (( vc != null )) {
				global::System.TypeCode _g = vc.GetTypeCode();
				switch (_g) {
					case global::System.TypeCode.Boolean:
					{
						return global::ValueType.TBool;
					}
					
					
					case global::System.TypeCode.Int32:
					{
						return global::ValueType.TInt;
					}
					
					
					case global::System.TypeCode.Double:
					{
						double d = vc.ToDouble(default(global::System.IFormatProvider));
						if (( ( ( d >= global::System.Int32.MinValue ) && ( d <= global::System.Int32.MaxValue ) ) && ( d == vc.ToInt32(default(global::System.IFormatProvider)) ) )) {
							return global::ValueType.TInt;
						}
						else {
							return global::ValueType.TFloat;
						}
						
					}
					
					
					default:
					{
						return global::ValueType.TClass(((global::System.Type) (t) ));
					}
					
				}
				
			}
			else {
				return global::ValueType.TClass(((global::System.Type) (t) ));
			}
			
		}
		
		if (( v is global::haxe.lang.IHxObject )) {
			if (( v is global::haxe.lang.DynamicObject )) {
				return global::ValueType.TObject;
			}
			else if (( v is global::haxe.lang.Enum )) {
				return global::ValueType.TEnum(((global::System.Type) (t) ));
			}
			
			return global::ValueType.TClass(((global::System.Type) (t) ));
		}
		else if (( v is global::haxe.lang.Function )) {
			return global::ValueType.TFunction;
		}
		else {
			return global::ValueType.TClass(((global::System.Type) (t) ));
		}
		
	}
	
	
	public static bool enumEq<T>(T a, T b) {
		if (global::haxe.lang.Runtime.eq(a, default(T))) {
			return global::haxe.lang.Runtime.eq(b, default(T));
		}
		else if (global::haxe.lang.Runtime.eq(b, default(T))) {
			return false;
		}
		else {
			return a.Equals(b);
		}
		
	}
	
	
	public static int enumIndex(object e) {
		if (( e is global::System.Enum )) {
			global::System.Array values = global::System.Enum.GetValues(((global::System.Type) (e.GetType()) ));
			return global::System.Array.IndexOf(((global::System.Array) (values) ), ((object) (e) ));
		}
		else {
			return (((global::haxe.lang.Enum) (e) )).index;
		}
		
	}
	
	
}


